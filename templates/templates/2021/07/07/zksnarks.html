

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">



<link rel="alternate" type="application/rss+xml" href="/feed.xml" title="ZK-snarks: A 30,000 Foot View">



<link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='styles/common-vendor.b8ecfc406ac0b5f77a26.css') }}">
<link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='styles/font-vendor.b86e2bf451b246b1a88e.css') }}">
<link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='styles/fretboard.f32f2a8d5293869f0195.css') }}">
<link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='styles/pretty.0ae3265014f89d9850bf.css') }}">
<link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='styles/pretty-vendor.83ac49e057c3eac4fce3.css') }}">
<link rel="stylesheet" type="text/css" href="{{ url_for('static',filename='styles/misc.css') }}">

<script type="text/javascript" id="MathJax-script" async
  src="/scripts/mathjax.js">
</script>

<style>
@font-face {
    font-family: MJXc-TeX-math-Iw;
    src: url("https://assets.hackmd.io/build/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff")
}
@font-face {
    font-family: MJXZERO;
    src: url("https://assets.hackmd.io/build/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff")
}
@font-face {
    font-family: MJXTEX;
    src: url("https://assets.hackmd.io/build/MathJax/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff")
}

.math { font-family: MJXc-TeX-math-Iw }
</style>

<div id="doc" class="container-fluid markdown-body comment-enabled" data-hard-breaks="true">


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="ZK-snarks: A 30,000 Foot View" />
<meta name="twitter:image" content="http://vitalik.ca/images/icon.png" />


<br>
<h1 style="margin-bottom:7px"> ZK-snarks: A 30,000 Foot View </h1>
<small style="float:left; color: #888"> 2021 Jul 07 </small>
<small style="float:right; color: #888"><a href="/">See all posts</a></small>
<br> <br> <br>
<title> ZK-snarks: A 30,000 Foot View </title>

<p>ZK-snarks, or <strong>Z</strong>ero-<strong>K</strong>nowledge <strong>S</strong>ucci<strong>N</strong>ct <strong>AR</strong>guments of <strong>K</strong>nowledge are a very complicated form of mathematical proof. Theoretically, they are used as a form of trustless communication: prove to me that you know something without revealing the details of what you know. The classic example is explained using the Where's Wally franchise. Can we prove that we know where Wally is without revealing his actual position?</p>
<p>Set up a floor to ceiling wall between the prover (us) and the person to which we are proving our positional knowledge of Mr.Â Wally. Cut a tiny rectangle in the wall, just large enough to show the elusive Wally's smug (yet unqiuely distinguishable) facial features. Now, position the map such that Wally's face peeks through the hole, but nothing else about his surroundings is revealed. Here, it is important to note that in this scenario, the viewer (the person we are proving our knowledge to) has absolutely no frame of reference which could be used to figure out where Wally is from our demonstration.</p>
<figure>
<img src="static/../../static/wally.png" alt="The simple (yet terrifying) POW (Proof Of Wally)" /><figcaption aria-hidden="true">The simple (yet terrifying) POW (Proof Of Wally)</figcaption>
</figure>
<p>This, at an extremely generalized level, is a zero-knowledge proof, or more specifically a ZK-snark. Applications abound, and while I am still figuring out the differences between the different species of the ZK family, the core idea remains incredibly powerful. Originally, ZK-snarks were used for very niche proofs in computer science, however, they have since been extended to abstract arguments and have in fact been shown to sumurize ANY form of knowledge.</p>
<p>For example, using ZK-snarks, we are able to prove that we have a checking account balance larger than $100,000 without revealing the balance itself. We would be able to prove that we have a disability, and qualify for grants, without revealing anything about the nature of that disability. However, these applications are still relatively far out, as the deal with the incredibly sensitive details of human society. Much work will need to be done before ZK-snarks could remove the cost of trust.</p>
<p>However, this does not mean that fascinating near-term applications of ZK-snarks do not exist. ZK-snarks can also be used, excitingly as proofs of computation. Vitalik Buterin (our king) gave a simple example of a hash function. For you noobs who don't know what that is, don't worry. No one really knows the details of state of the art hash functions, else they would cease to be true hash functions. For the sake of space, a hash function is simply a mechanism which scrambles a piece of data beyond recognition, such that there is no way (in theory) to figure out how to find the original data from the scrambled version of it.</p>
<p>Eg: if we started with the phrase: "I love her lack of energy! Go girl give us nothing" and hashed it, we would probably get something to the effect of "ib3obi8q375n7t8nt7fin8qt3o847tn283otc4j17934tnc13o47bc1r38n4o". If you saw that key-mash right there, there is very little chance that you would be able to figure out that it was derived from the phrase "I love her lack of energy! Go girl give us nothing".</p>
<p>This is the essence of hashing. For you math-nerds, a hash function is a <strong>one-way function</strong> - something which actually has yet to be proven to exist. Hash and one-way functions are based on the myth of randomness, which probably does not exist in pure form.</p>
<p>Anyway, I'm getting sidetracked. As I said, a modern application of ZK-snarks can be found in proof-of-computation. Say we take the quintessential "I love her lack of energy! Go girl give us nothing", and hashed it 1 trillion times - taking a hash of each previous hash. This is a huge amount of work, even for modern supercomputers. Our final output would be something like "aisjeoit792co57236jn5c2835ckuilhsminug2i7345tl2xjo35", and this garbled string could be offered as a form of proof of computation by us to the verifier of the computation. However, this presents a problem: how does the verifierprove that the 1 trillion hashes have been performed without having to re-do the massive amount of computation themself? How do we prove something with less effort than it took to calculate it?</p>
<p>For most mathematical calculations, this is easy. If we have a function x^45 + 49x^32 + x^21 + 1 = 978751264 and we claimed to have a solution to it in the form (x1), we could simply hand this solution to the verfier for testing. The verifier could plug this number - x1 - into the equation, and check that Right-Hand-Side equals Left-Hand-Side. Done! It would be vastly inefficient for the verifier to check the proof by finding the root through attempting to re-calculate it / replicate the process of the prover.</p>
<p>At first glance, extending this simple math example to hash-functions or other, more abstract proofs such as the proof of disability mentioned earlier might seem tricky, or nigh-impossible. Fear not, however, for ZK-snarks save the day.</p>
<p>I am in no way going to go into the details of how ZK-snarks function under the hood. The full details of the math is quite literally beyond me at this stage. However, abstracting naively from the sparse amount of reading and research I have done on the subject, ZK-snarks aim to encode problems as polynomials and provide a proof in the form of a solution (or root) of that polynomial. That is, given a large, complicated encoding of a problem y = f(x), we provide a proof that we have solved that problem in the form of a solution (x1, x2, x3 ...).</p>
<p>Continuing with our wonderful Wally example, we might be able to encode the gnarly map containg Wally in a crowd as some function. The solution to this function would be two numbers y1, and y2 representing the coordinates of Wally. If we provided a vector (or matrix) X containing the values which, when plugged into the function, would yield the correct cordinates of Wally, we would have proven to the verifier that we know how to find Wally, at least for this example. It is key to note that we did not reveal our method(s) of searching for Wally. The verifier has no idea if we sent a search team for him, if we determined his position algorithmically, whether we implanted a tracker in his arm, NOTHING. In theory, there is no way for the verifier to replicate our methods and copy them. They simply know that we know something, without knowing the details of <strong>how</strong> we know it; The verifier knows that we are telling the truth without knowing the details of that truth.</p>
<p>This is a very basic form of a ZK-SNARK. For the skeptical verifier, this process of proof could be completed a number of times with different maps and different solutions until the verifier is convinced that the prover is telling the truth.</p>
<p>Like any metaphor, this one is not perfect. We would still be revealing a key piece of valuable information - the position of Wally. If we provide a solution to the encoded map-problem, the verifier could then use that solution to find Wally, and exploit him for labour. Obviously this is not ideal, and ways have been derived in which to prove we know the solution to a problem without even revealing the solution itself!</p>
<p>This gets very complicated, and might be detailed in another post. I'm bad at conclusions so yes, those are the basics of how ZK-snarks work from a VERY high level. I encourage you to read more on them. SNARKS are an emerging field, and so please reach out to me at jstapleton17@apu.edu for any further questions (or, if you have corrections to what I said here).</p>
 </div> 